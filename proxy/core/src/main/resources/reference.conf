cloudstate.proxy {
    dev-mode-enabled = false
    ready-timeout = 1s
    http-interface = "0.0.0.0"
    http-port = 9000
    http-port = ${?HTTP_PORT}
    user-function-host = "127.0.0.1"
    user-function-host = ${?USER_FUNCTION_HOST}
    user-function-port = 8080
    user-function-port = ${?USER_FUNCTION_PORT}
    relay-timeout = 1m
    max-inbound-message-size = 12M
    relay-buffer-size = 100
    graceful-termination-timeout = 10s
    passivation-timeout = 30s // Keep short for testing purposes
    number-of-shards = 100
    proxy-parallelism = 100
    backoff {
      min = 1s
      max = 10s
      random-factor = 0.2
    }

    # If using a config that enables it, then set to true
    journal-enabled = false

    telemetry {
        # Whether telemetry (instrumentation and prometheus exporter) should be disabled
        disabled = ${cloudstate.proxy.dev-mode-enabled}

        prometheus {
            # Prometheus exporter host
            host = "0.0.0.0"
            host = ${?METRICS_HOST}

            # Prometheus exporter port
            port = 9090
            port = ${?METRICS_PORT}

            # Whether to use the Prometheus default registry (or create a separate registry)
            use-default-registry = true
        }
    }

    autoscaler {
        # For now, disable it because CRDTs don't yet support autoscaling
        enabled = false
        enabled = ${?AUTOSCALER_ENABLED}

        target-concurrency {
            user-function = 1
            user-function = ${?USER_FUNCTION_TARGET_CONCURRENCY}

            request = 50
            request = ${?REQUEST_TARGET_CONCURRENCY}

            window = 1m
            window = ${?TARGET_CONCURRENCY_WINDOW}
        }

        scale-up-stable-deadline = 3m
        scale-up-stable-deadline = ${?SCALE_UP_STABLE_DEADLINE}
        scale-down-stable-deadline = 30s
        scale-down-stable-deadline = ${?SCALE_DOWN_STABLE_DEADLINE}

        request-rate {
            threshold-factor = 1.5
            threshold-factor = ${?REQUEST_RATE_THRESHOLD_FACTOR}

            window = 6s
            threshold-factor = ${?REQUEST_RATE_WINDOW}
        }

        max-scale-factor = 0.0
        max-scale = 2
        max-members = 100

        tick-period = 2s
    }

    # Configures the eventing functionality
    eventing {
        # Valid options are currently: "none", and "google-pubsub"
        support = "none"

        # This configuration is used when support is set to "google-pubsub"
        google-pubsub {
            # Where to connect to, use "pubsub.googleapis.com" to connect to Google Cloud Pubsub.
            host = "pubsub.googleapis.com"

            # What port to connect to, use 443 for Google Cloud Pubsub.
            port = 443

            # Set to "none" to disable TLS.
            # Valid options are, "none", and "GoogleInternetAuthorityG3.crt"
            rootCa = "none"

            # Valid options are, "none", and "google-application-default".
            callCredentials = "none"

            # The identifier of the Google Pubsub Project to use, must be set.
            project-id = ""
            project-id = ${?PUBSUB_PROJECT_ID}

            # Sets the frequency of retrieving messages
            poll-interval = 1s

            # Sets the deadline for a message to be ack:ed, must be 10-600s
            upstream-ack-deadline = 10s

            # Sets the deadline for determining when a batch of outbound messages is ready to be sent.
            # If set to 0 then batching will be turned off.
            downstream-batch-deadline = 5s

            # Sets the maximum size for a batch of outbound messages, must be greater than 0.
            # If set to 1 then batching will be turned off.
            downstream-batch-size = 10

            # Valid options are: "manually", "by-proxy"
            # "manually" means that they are created and configured manually
            # "by-proxy" means that the proxy will create the subscriptions and topics if needed
            # NOT AVAILABLE YET: "using-crd" means that the proxy will create CRDs and a k8s operator will manage them
            manage-topics-and-subscriptions = "manually"
        }
    }

    # Enable the Value Entity functionality by setting it to true
    value-entity-enabled = false

    # Configures the persistence store for the Value Entity when value-entity-enabled is true
    value-entity-persistence-store {
        # This property indicate the type of store to be used for Value Entity.
        # Valid options are: "using-jdbc", "in-memory"
        # "in-memory" means the data are persisted in memory.
        # "jdbc" means the data are persisted in a configured native JDBC database.
        store-type = "in-memory"

        # This property indicates which configuration must be used by Slick.
        jdbc.database.slick {
            connectionPool = "HikariCP"

            # This property indicates which profile must be used by Slick.
            # Possible values are: slick.jdbc.PostgresProfile$, slick.jdbc.MySQLProfile$ and slick.jdbc.H2Profile$
            # (uncomment and set the property below to match your needs)
            # profile = "slick.jdbc.PostgresProfile$"

            # The JDBC driver to use
            # (uncomment and set the property below to match your needs)
            # driver = "org.postgresql.Driver"

            # The JDBC URL for the chosen database
            # (uncomment and set the property below to match your needs)
            # url = "jdbc:postgresql://localhost:5432/cloudstate"

            # The database username
            # (uncomment and set the property below to match your needs)
            # user = "cloudstate"

            # The database password
            # (uncomment and set the property below to match your needs)
            # password = "cloudstate"


            ## copy and adapted from akka-persistece-jdbc

            # hikariCP settings; see: https://github.com/brettwooldridge/HikariCP
            # Slick will use an async executor with a fixed size queue of 10.000 objects
            # The async executor is a connection pool for asynchronous execution of blocking I/O actions.
            # This is used for the asynchronous query execution API on top of blocking back-ends like JDBC.
            queueSize = 10000 // number of objects that can be queued by the async exector

            # This property controls the maximum number of milliseconds that a client (that's you) will wait for a connection
            # from the pool. If this time is exceeded without a connection becoming available, a SQLException will be thrown.
            # 1000ms is the minimum value. Default: 180000 (3 minutes)
            connectionTimeout = 180000

            # This property controls the maximum amount of time that a connection will be tested for aliveness.
            # This value must be less than the connectionTimeout. The lowest accepted validation timeout is 1000ms (1 second). Default: 5000
            validationTimeout = 5000

            # 10 minutes: This property controls the maximum amount of time that a connection is allowed to sit idle in the pool.
            # Whether a connection is retired as idle or not is subject to a maximum variation of +30 seconds, and average variation
            # of +15 seconds. A connection will never be retired as idle before this timeout. A value of 0 means that idle connections
            # are never removed from the pool. Default: 600000 (10 minutes)
            idleTimeout = 600000

            # 30 minutes: This property controls the maximum lifetime of a connection in the pool. When a connection reaches this timeout
            # it will be retired from the pool, subject to a maximum variation of +30 seconds. An in-use connection will never be retired,
            # only when it is closed will it then be removed. We strongly recommend setting this value, and it should be at least 30 seconds
            # less than any database-level connection timeout. A value of 0 indicates no maximum lifetime (infinite lifetime),
            # subject of course to the idleTimeout setting. Default: 1800000 (30 minutes)
            maxLifetime = 1800000

            # This property controls the amount of time that a connection can be out of the pool before a message is logged indicating a
            # possible connection leak. A value of 0 means leak detection is disabled.
            # Lowest acceptable value for enabling leak detection is 2000 (2 secs). Default: 0
            leakDetectionThreshold = 0

            # ensures that the database does not get dropped while we are using it
            keepAliveConnection = on

            # See some tips on thread/connection pool sizing on https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing
            # Keep in mind that the number of threads must equal the maximum number of connections.
            numThreads = 5
            maxConnections = 5
            minConnections = 5

            # This property controls a user-defined name for the connection pool and appears mainly in logging and JMX
            # management consoles to identify pools and pool configurations. Default: auto-generated
            poolName = "cloudstate-value-entity-connection-pool"
        }

        # This property indicates the table in use for the Value Entity.
        jdbc-state-store {
            tables {
                state {
                    tableName = "value_entity_state"
                    schemaName = ""
                    columnNames {
                        persistentId = "persistent_id"
                        entityId = "entity_id"
                        state = "state"
                    }
                }
            }
        }
    }
}
